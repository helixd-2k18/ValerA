#include "./vlr/Resampling.hpp"
#include "./vlr/PipelineLayout.hpp"
#include "./vlr/Framebuffer.hpp"
#include "./vlr/Geometry.hpp"

namespace vlr {

    void Resampling::constructor(vkt::uni_ptr<Driver> driver, vkt::uni_arg<PipelineCreateInfo> info) {
        this->driver = driver, this->layout = info->layout, this->framebuffer = info->framebuffer; auto device = this->driver->getDeviceDispatch();
        this->stages = { // for faster code, pre-initialize
            vkt::makePipelineStageInfo(device, vkt::readBinary(std::string("./shaders/resampling.vert.spv")), VK_SHADER_STAGE_VERTEX_BIT),
            vkt::makePipelineStageInfo(device, vkt::readBinary(std::string("./shaders/resampling.geom.spv")), VK_SHADER_STAGE_GEOMETRY_BIT),
            vkt::makePipelineStageInfo(device, vkt::readBinary(std::string("./shaders/resampling.frag.spv")), VK_SHADER_STAGE_FRAGMENT_BIT)
        };

        // 
        const auto& viewport = reinterpret_cast<vkh::VkViewport&>(framebuffer->viewport);
        const auto& renderArea = reinterpret_cast<vkh::VkRect2D&>(framebuffer->scissor);

        // Enable Conservative Rasterization For Fix Some Antialiasing Issues
        this->conserv.conservativeRasterizationMode = VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT;
        this->pipelineInfo = vkh::VsGraphicsPipelineCreateInfoConstruction();
        this->pipelineInfo.stages = this->stages;
        this->pipelineInfo.depthStencilState = vkh::VkPipelineDepthStencilStateCreateInfo{ .depthTestEnable = true, .depthWriteEnable = true };
        this->pipelineInfo.dynamicStates.push_back(VK_DYNAMIC_STATE_VIEWPORT);
        this->pipelineInfo.dynamicStates.push_back(VK_DYNAMIC_STATE_SCISSOR);
        this->pipelineInfo.dynamicStates.push_back(VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT);          // NEW!
        this->pipelineInfo.dynamicStates.push_back(VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT); // NEW!
        this->pipelineInfo.graphicsPipelineCreateInfo.renderPass = framebuffer->resampleFBO.renderPass;
        this->pipelineInfo.graphicsPipelineCreateInfo.layout = layout->pipelineLayout;
        this->pipelineInfo.viewportState.pViewports = viewport;
        this->pipelineInfo.viewportState.pScissors = renderArea;

        // 
        for (uint32_t i = 0u; i < 8u; i++) {
            this->pipelineInfo.colorBlendAttachmentStates.push_back(framebuffer->resampleFBO.blendStates[i]); // transparency will generated by ray-tracing
        };

        // 
        vkh::handleVk(device->CreateGraphicsPipelines(driver->getPipelineCache(), 1u, this->pipelineInfo, nullptr, &this->pipeline));
    };

    void Resampling::setCommand(vkt::uni_arg<VkCommandBuffer> resampleCommand, vkt::uni_arg<glm::uvec4> meta){
        const auto& viewport = reinterpret_cast<vkh::VkViewport&>(framebuffer->viewport);
        const auto& renderArea = reinterpret_cast<vkh::VkRect2D&>(framebuffer->scissor);

        // 
        auto device = this->driver->getDeviceDispatch();

        // 
        device->CmdBindPipeline(resampleCommand, VK_PIPELINE_BIND_POINT_GRAPHICS, this->pipeline);
        device->CmdBindDescriptorSets(resampleCommand, VK_PIPELINE_BIND_POINT_GRAPHICS, layout->pipelineLayout, 0u, layout->bound.size(), layout->bound.data(), 0u, nullptr);
        device->CmdSetViewport(resampleCommand, 0u, 1u, viewport);
        device->CmdSetScissor(resampleCommand, 0u, 1u, renderArea);
        device->CmdSetPrimitiveTopologyEXT(resampleCommand, VK_PRIMITIVE_TOPOLOGY_POINT_LIST);
        device->CmdPushConstants(resampleCommand, layout->pipelineLayout, layout->stages, 0u, sizeof(glm::uvec4), &meta);
        device->CmdBeginRenderPass(resampleCommand, vkh::VkRenderPassBeginInfo{ .renderPass = framebuffer->resampleFBO.renderPass, .framebuffer = framebuffer->resampleFBO.framebuffer, .renderArea = renderArea, .clearValueCount = static_cast<uint32_t>(framebuffer->resampleFBO.clearValues.size()), .pClearValues = framebuffer->resampleFBO.clearValues.data() }, VK_SUBPASS_CONTENTS_INLINE);
        device->CmdDraw(resampleCommand, framebuffer->width, framebuffer->height, 0u, 0u); // TODO: Instanced Support
        device->CmdEndRenderPass(resampleCommand);
    };

};
