#include "./vlr/Rasterization.hpp"
#include "./vlr/PipelineLayout.hpp"
#include "./vlr/Framebuffer.hpp"
#include "./vlr/Geometry.hpp"

namespace vlr {

    void Rasterization::constructor(vkt::uni_ptr<Driver> driver, vkt::uni_arg<PipelineCreateInfo> info) {
        this->driver = driver, this->info = info;
        this->stages = { // for faster code, pre-initialize
            vkt::makePipelineStageInfo(this->driver->getDeviceDispatch(), vkt::readBinary(std::string("./shaders/rasterize.vert.spv")), VK_SHADER_STAGE_VERTEX_BIT),
            vkt::makePipelineStageInfo(this->driver->getDeviceDispatch(), vkt::readBinary(std::string("./shaders/rasterize.frag.spv")), VK_SHADER_STAGE_FRAGMENT_BIT)
        };
        
        //
        const auto& viewport = reinterpret_cast<vkh::VkViewport&>(info->framebuffer->viewport);
        const auto& renderArea = reinterpret_cast<vkh::VkRect2D&>(info->framebuffer->scissor);

        // Enable Conservative Rasterization For Fix Some Antialiasing Issues
        this->conserv.conservativeRasterizationMode = VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT;
        this->pipelineInfo = vkh::VsGraphicsPipelineCreateInfoConstruction();
        this->pipelineInfo.stages = this->stages;
        this->pipelineInfo.depthStencilState = vkh::VkPipelineDepthStencilStateCreateInfo{ .depthTestEnable = true, .depthWriteEnable = true };
        this->pipelineInfo.dynamicStates.push_back(VK_DYNAMIC_STATE_VIEWPORT);
        this->pipelineInfo.dynamicStates.push_back(VK_DYNAMIC_STATE_SCISSOR);
        this->pipelineInfo.dynamicStates.push_back(VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT);          // NEW!
        this->pipelineInfo.dynamicStates.push_back(VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT); // NEW!
        this->pipelineInfo.graphicsPipelineCreateInfo.renderPass = info->framebuffer->rasterFBO.renderPass;
        this->pipelineInfo.graphicsPipelineCreateInfo.layout = info->pipelineLayout->pipelineLayout;
        this->pipelineInfo.rasterizationState.pNext = &this->conserv;
        this->pipelineInfo.viewportState.pViewports = viewport;
        this->pipelineInfo.viewportState.pScissors = renderArea;

        // 
        for (uint32_t i = 0u; i < 8u; i++) {
            this->pipelineInfo.colorBlendAttachmentStates.push_back(info->framebuffer->rasterFBO.blendStates[i]); // transparency will generated by ray-tracing
        };

        // 
        vkh::handleVk(this->driver->getDeviceDispatch()->CreateGraphicsPipelines(driver->getPipelineCache(), 1u, this->pipelineInfo, nullptr, &this->pipeline));
    };

    void Rasterization::setCommand(vkt::uni_arg<VkCommandBuffer> rasterCommand, glm::uvec4 meta){
        const auto& viewport = reinterpret_cast<vkh::VkViewport&>(info->framebuffer->viewport);
        const auto& renderArea = reinterpret_cast<vkh::VkRect2D&>(info->framebuffer->scissor);

        // covergence
        this->driver->getDeviceDispatch()->CmdBindPipeline(rasterCommand, VK_PIPELINE_BIND_POINT_GRAPHICS, this->pipeline);
        this->driver->getDeviceDispatch()->CmdBindDescriptorSets(rasterCommand, VK_PIPELINE_BIND_POINT_GRAPHICS, this->info->pipelineLayout->pipelineLayout, 0u, this->info->pipelineLayout->bound.size(), this->info->pipelineLayout->bound.data(), 0u, nullptr);
        this->driver->getDeviceDispatch()->CmdSetViewport(rasterCommand, 0u, 1u, viewport);
        this->driver->getDeviceDispatch()->CmdSetScissor(rasterCommand, 0u, 1u, renderArea);
        this->driver->getDeviceDispatch()->CmdSetPrimitiveTopologyEXT(rasterCommand, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST);
        this->driver->getDeviceDispatch()->CmdPushConstants(rasterCommand, this->info->pipelineLayout->pipelineLayout, info->pipelineLayout->stages, 0u, sizeof(meta), &meta);
        this->driver->getDeviceDispatch()->CmdBeginRenderPass(rasterCommand, vkh::VkRenderPassBeginInfo{ .renderPass = info->framebuffer->rasterFBO.renderPass, .framebuffer = info->framebuffer->rasterFBO.framebuffer, .renderArea = renderArea, .clearValueCount = static_cast<uint32_t>(info->framebuffer->rasterFBO.clearValues.size()), .pClearValues = info->framebuffer->rasterFBO.clearValues.data() }, VK_SUBPASS_CONTENTS_INLINE);

        // 
        if (geometry->indexType != VK_INDEX_TYPE_NONE_KHR && geometry->indexBufferView != ~0u && geometry->indexBufferView != -1) {
            const auto& buffer = geometry->vertexSet->getBuffer(geometry->indexBufferView);
            this->driver->getDeviceDispatch()->CmdBindIndexBuffer(rasterCommand, buffer, buffer.offset(), geometry->indexType);
            this->driver->getDeviceDispatch()->CmdDrawIndexed(rasterCommand, geometry->desc->primitiveCount * 3u, 1u, geometry->desc->firstVertex, 0u, 0u);
        } else {
            this->driver->getDeviceDispatch()->CmdDraw(rasterCommand, geometry->desc->primitiveCount * 3u, 1u, geometry->desc->firstVertex, 0u); // TODO: Instanced Support
        };
        
        // 
        this->driver->getDeviceDispatch()->CmdEndRenderPass(rasterCommand);
    };

};
