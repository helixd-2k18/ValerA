#version 460 core
#extension GL_GOOGLE_include_directive : require
#define GLSL

#include "../include/driver.hlsli"
#include "../include/bindings.hlsli"

#define LAUNCH_ID GlobalInvocationID




// TODO: HLSL
#ifdef GLSL
layout ( local_size_x = 256u, local_size_y = 1u ) in; 
void main() 
#else

#endif
{
#ifdef GLSL
    const uint3 GlobalInvocationID = gl_GlobalInvocationID;
    const uint3 LocalInvocationID = gl_LocalInvocationID;
    const uint LocalInvocationIndex = gl_LocalInvocationIndex;
    const uint3 NumWorkGroups = gl_NumWorkGroups;
    const uint3 WorkGroupID = gl_WorkGroupID;
    const uint3 WorkGroupSize = gl_WorkGroupSize;
#endif

    const uint fcount = counters[RAY_COUNTER_READ];
    const uint wcount = tiled(tiled(fcount, NumWorkGroups.x), WorkGroupSize.x) * WorkGroupSize.x * (fcount > 0u ? 1u : 0u);
    const uint woffset = WorkGroupID.x * wcount;
    for (uint i=0;i<wcount;i+=WorkGroupSize.x) {
        const uint gID = woffset + (i + LocalInvocationIndex);
        packed = gID, seed = uint2(packed, constants.rdata.x);
        if (gID < fcount) {
            HitData hit = hits[0u].data[gID];
            RayData ray = rays[1u].data[gID];

            XHIT xhit;
            xhit.origin = float4(ray.origin, 1.f);
            xhit.direct = float4(ray.direct, 0.f);
            xhit.gBarycentric = float4(hit.barycentric, hit.dist);
            xhit.gIndices = uint4(hit.indices, 0u);

            // Interpolate In Ray-Tracing
            XGEO geometry = interpolate(xhit);
            XPOL material = materialize(xhit, geometry);

            // 
            const float3 mapNormal = geometry.gNormal.xyz;//material.mapNormal.xyz;
            const float3x3 TBN = float3x3(geometry.gTangent.xyz,geometry.gBinormal.xyz,mapNormal);

            // 
            RayData outRay = ray;
            if (xhit.gBarycentric.w > 9999.f) {
                outRay.emission = half4(float4(outRay.color.xyz, 1.f) * gSkyShader(xhit.direct.xyz, xhit.origin.xyz));
                outRay.color = half4(0.f);
                outRay.meta = u8vec4(0u);
                kind(outRay, DIFFUSE_RAY);
                lifetime(outRay, 0u);
                finished(outRay, true);
            } else 
            {
                outRay.pixelID = u16vec2(LAUNCH_ID);
                outRay.origin.xyz = ray.direct.xyz * xhit.gBarycentric.w + ray.origin.xyz;
                outRay.direct.xyz = randomHemisphereCosine(seed, TBN);//reflect(outRay.direct.xyz, mapNormal);
                outRay.origin.xyz += faceforward(geometry.gNormal.xyz, outRay.direct.xyz, -geometry.gNormal.xyz) * 0.001f;
                outRay.emission = half4(float4(outRay.color) * float4(material.emissionColor.xyz * material.emissionColor.w, 1.f));
                outRay.color = half4(float4(outRay.color) * float4(max(material.diffuseColor.xyz - clamp(material.emissionColor.xyz*material.emissionColor.w,0.f.xxx,1.f.xxx), 0.f.xxx), 1.f));
                outRay.meta = u8vec4(0u);
                kind(outRay, DIFFUSE_RAY);
                lifetime(outRay, lifetime(ray));
                finished(outRay, false);
            };
            emitRay(outRay);
        };
    };
};
